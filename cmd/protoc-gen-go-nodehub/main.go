package main

import (
	"fmt"
	"strings"

	"github.com/joyparty/gokit"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/dynamicpb"
)

// optionName 自定义配置名称
const optionName = "reply_code"

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		// The type information for all extensions is in the source files,
		// so we need to extract them into a dynamically created protoregistry.Types.
		extTypes := new(protoregistry.Types)
		for _, file := range gen.Files {
			gokit.Must(registerAllExtensions(extTypes, file.Desc))
		}

		for _, file := range gen.Files {
			if file.Generate {
				generateFile(gen, file, extTypes)
			}
		}
		return nil
	})
}

func generateFile(
	gen *protogen.Plugin,
	file *protogen.File,
	extTypes *protoregistry.Types,
) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	services := map[*protogen.Service]map[string]protoreflect.EnumNumber{}
	for _, s := range file.Services {
		codes := getReplyCodes(s, extTypes)
		if len(codes) > 0 {
			services[s] = codes
		}
	}

	if len(services) == 0 {
		return nil
	}

	g := gen.NewGeneratedFile(
		fmt.Sprintf("%s_nodehub.pb.go", file.GeneratedFilenamePrefix),
		file.GoImportPath,
	)

	g.P("// Code generated by protoc-gen-go-nodehub. DO NOT EDIT.")
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for s, codes := range services {
		genReplyCodes(g, s, codes)
	}

	return g
}

func genReplyCodes(g *protogen.GeneratedFile, s *protogen.Service, codes map[string]protoreflect.EnumNumber) {
	g.P("// ", s.GoName, "_ReplyCodes 每个grpc方法返回值对应的nodehub.Reply.code")
	g.P("var ", s.GoName, "_ReplyCodes = map[string]int32{")
	for methodFullname, code := range codes {
		g.P(fmt.Sprintf("\t%q: %d,", methodFullname, code))
	}
	g.P("}")
}

func getReplyCodes(s *protogen.Service, extTypes *protoregistry.Types) map[string]protoreflect.EnumNumber {
	getCode := func(method *protogen.Method, extTypes *protoregistry.Types) (code protoreflect.EnumNumber, ok bool) {
		options := method.Desc.Options().(*descriptorpb.MethodOptions)
		if options == nil {
			return
		}

		data := gokit.MustReturn(proto.Marshal(options))

		options.Reset()
		gokit.Must(proto.UnmarshalOptions{Resolver: extTypes}.Unmarshal(data, options))

		options.ProtoReflect().Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
			if fd.IsExtension() &&
				strings.HasSuffix(string(fd.FullName()), fmt.Sprintf(".%s", optionName)) {
				code = v.Enum()
				ok = true

				return false
			}
			return true
		})

		return
	}

	codes := make(map[string]protoreflect.EnumNumber)

	for _, method := range s.Methods {
		if code, ok := getCode(method, extTypes); ok {
			methodFullname := fmt.Sprintf("/%s/%s", s.Desc.FullName(), method.Desc.Name())
			codes[methodFullname] = code
		}
	}

	return codes
}

func registerAllExtensions(extTypes *protoregistry.Types, descs interface {
	Messages() protoreflect.MessageDescriptors
	Extensions() protoreflect.ExtensionDescriptors
},
) error {
	mds := descs.Messages()
	for i := 0; i < mds.Len(); i++ {
		registerAllExtensions(extTypes, mds.Get(i))
	}
	xds := descs.Extensions()
	for i := 0; i < xds.Len(); i++ {
		if err := extTypes.RegisterExtension(dynamicpb.NewExtensionType(xds.Get(i))); err != nil {
			return err
		}
	}
	return nil
}
